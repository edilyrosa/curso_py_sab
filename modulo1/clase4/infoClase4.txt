# #***********************************************WHILE**************************************
# Para repetir un bloque de c√≥digo mientras una condici√≥n se cumpla (es verdadera).  
# El c√≥digo dentro del bucle se ejecuta repetidamente hasta que la condici√≥n se vuelve falsa.

#* SINTAXIS
# inicializaci√≥n de la variable de control ‚ö†Ô∏è
# ‚≠êwhile condici√≥n:
#     # Bloque de c√≥digo a ejecutar mientras la condici√≥n sea True
#     # Actualizaci√≥n de la variable de control ‚ö†Ô∏èüö©

# *‚ÅâÔ∏èC√≥mo funciona
# Se eval√∫a la condici√≥n.
# Si la condici√≥n es verdadera (True), se ejecuta el bloque de c√≥digo.
# Luego se vuelve a evaluar la condici√≥n.
# Cuando la condici√≥n es falsa (False), se sale del bucle y se contin√∫a con el resto del programa.
************************************************Codigo explicacion....******************************************


# *‚≠êUso t√≠pico del while
# Cuando no sabemos de antemano cu√°ntas veces se repetir√° el ciclo.
# Cuando la repetici√≥n depende de una condici√≥n din√°mica cambiante, o del usuario.
# En combinaci√≥n con break para salir anticipadamente.
************************************************Codigo explicacion....******************************************



#*‚õπüèΩ‚Äç‚ôÇÔ∏è‚õπüèΩ‚Äç‚ôÄÔ∏èüí°EJERCICIO #1: Genere y muestre la tabla de multiplicar de un n√∫mero espec√≠fico.üí°‚õπüèΩ‚Äç‚ôÇÔ∏è‚õπüèΩ‚Äç‚ôÄÔ∏è
# El programa debe pedirle al usuario que ingrese un n√∫mero entero y luego,
# utilizando un bucle, debe imprimir la tabla de multiplicar de ese n√∫mero del 1 al 10.
************************************************Codigo Solucion....******************************************






# #***********************************************DICT**************************************
# *TDD dict
# Se crea con llaves {}. 
# Colecci√≥n de datos que almacena informaci√≥n en pares de clave:valor. 

# Con Asignaci√≥n puedes crear un nuevo par (c:v) 
# o actualiza, utilizando la clave (como indice) para acceder al valor. 
# Con la asignacion, Si la clave ya existe haces actualizacion, sino creacion del elemento.

# Cada elemento es un par (c:v), y deben estar separados por ‚Äú,‚Äù
# ? ‚ÅâÔ∏èQUE TDD PUEDEN SER CLAVE Y VALUE?


# clave: debe ser TDD inmutable (como un str, int, o tuple).
# valor: puede ser de cualquier TDD.
#***CREACION****
#***ACCESO A VALUES****
************************************************Codigo explicacion....******************************************

#*METODOS
# Tama√±o: con len(dict), retorna el n√∫mero de elementos.
# Mutabilidad: Son mutables, puedes agregar, eliminar y modificar elementos. Las claves son irrepetibles.
#Actualizar o crear depende de si la clave YA existe.

# Acceder al Valor: 
    # dict[clave]: Lanza error si la clave no existe
    # valor = mi_diccionario.get(clave): Retorna None o un valor por defecto si la clave no existe.

# Eliminar un Elemento:
    # dict.pop(clave): Elimina el elemento y retorna el valor
    # dict.popitem(): Elimina el ultimo elemento.
    # del dict[clave] Elimina el elemento sin retornar nada.

# Vaciar Diccionario: Elimina todos los elementos.
    # dict.clear()

# Verificar Clave: Comprueba si una clave existe. Retorna bool.
    # clave in dict
************************************************Codigo explicacion....******************************************



#*RECORRERLOS O ITERRALOS
# Ordenados: mantienen el orden de inserci√≥n de los elementos.
# for clave in dict -> defalult, itera sobre las claves
# dict.values() -> itera sobre los valores
# dict.items() -> itera sobre los pares clave-valores al mismo tiempo
************************************************Codigo explicacion....******************************************


#TODO: ‚õπüèΩ‚Äç‚ôÇÔ∏è‚õπüèΩ‚Äç‚ôÄÔ∏èüí°EJERCICIO # 2: CREA UN DICT CON 5 ELEMENTOS, LAS CLAVES SERAN {1,2,3,4,5} Y LOS VALORES SERAN EL CUADRADO DE LAS CLAVES
# CREA EL DICT VACIO, LUEGO MEDIANTE UN FOR ITERA UN RANGE(1,6) PARA CREAR LOS PARES (c:v)
************************************************Codigo Solucion....******************************************
#....
#üìñüëÄ‚ÅâÔ∏è A diferencia de las listas, a un dict vac√≠o s√≠ puedes asignar directamente valores usando una clave nueva, 
# incluso si el dict est√° inicialmente vac√≠o.
lista_vacia = []
#lista_vacia[0] = 'hola'  #! Esto produce IndexError: list assignment index out of range

# Esto ocurre porque la lista inicialmente no tiene elementos y no se puede asignar directamente a un √≠ndice inexistente.
# Para agregar elementos a una lista vac√≠a debes usar m√©todos como:
# append() para a√±adir al final




#TODO: ‚õπüèΩ‚Äç‚ôÇÔ∏è‚õπüèΩ‚Äç‚ôÄÔ∏èüí°EJERCICIO #3 : mapeando un dict para encontra TDD num y aplicar descuento.üí°‚õπüèΩ‚Äç‚ôÇÔ∏è‚õπüèΩ‚Äç‚ôÄÔ∏è
persona_ejercicio = {
    'nombre': 'Ana',
    'femenina': True,
    102: 100,
    'hobbies': ['leer', 'viajar', 'codear'],
    'contacto': {
        'email': 'ana@ejemplo.com',
        'telefono': '555-1234'
    },
    ('latitud', 'longitud'): [40.7128, -74.006],
    (1, 2, 3): [10, 20, 30]
}
# Instrucciones:
# Recorre el diccionario dict _ejercicio con un ciclo for.
# Para cada elemento, verifica si el valor asociado es un n√∫mero (ya sea entero o decimal).
# Usa la funci√≥n: isinstance(valor, (int, float)) para hacer esta comprobaci√≥n.
# ‚≠êisinstance(valor, (int, float)) -> verifica si valor es un de tipo int o float. Retorna bool.
# Si el valor es num√©rico, calcula y aplica un descuento del 20% a ese valor.
# Por cada valor num√©rico modificado, imprime un mensaje en el siguiente formato:
# La clave es "clave", se le aplica un descuento del 20% a su valor original VALOR_ORIGINAL,
# resultando en VALOR_CON_DESCUENTO.
************************************************Codigo Solucion....******************************************


#*COPIAR UN DICT
#  ? Copia Superficial: .copy() || dict()
# Crea un nuevo dict, pero si el original contiene objetos mutables
# (list o dict), ambos diccionarios apuntar√°n a los mismos objetos. 
# Cualquier cambio en esos objetos anidados afectar√° a ambas copias.
# Uso: Si solo contiene TDD inmutables (str, int, tuple).

# ?Copia Profunda: import copy; copy.deepcopy()
# Crea un diccionario totalmente independiente, replicando todos los objetos anidados. 
# Uso: El contiene objetos mutables anidados que necesitas que sean independientes de la copia original.
edily = {
    'genero':'F',
    "edad":30,                                                    # ‚úÖTDD valor es int: INmutable, los cambios NO afectan al otro
    ("materias", 'calificaciones'): [['math', 'bio'], [20, 19]],  # ‚ö†Ô∏èTDD valor es List: Mutable, los cambios SI afectan al otro
    "telefonos":{                                                 # ‚ö†Ô∏èTDD valor es dict: Mutable, los cambios SI afectan al otro
        "casa":42499,
        "ofi":42400,
    }
}
************************************************Codigo explicacion....******************************************

#*‚õπüèΩ‚Äç‚ôÇÔ∏è‚õπüèΩ‚Äç‚ôÄÔ∏èüí°EJERCICIO #4: Manupulacion de copia profunda de dictüí°‚õπüèΩ‚Äç‚ôÇÔ∏è‚õπüèΩ‚Äç‚ôÄÔ∏è
# Crea una copia profunda del diccionario producto (usando copy.deepcopy).
# 1. En la copia:
# 2. Agrega el elemento 'moneda' con el valor ('$', '‚Ç¨'), imprimelo.
# 3. Agrega el elemento 'precio_moneda' ( tipo string ), que resultar√° de concatenar el primer elemento de la clave moneda ('$') al valor de 'precio', imprimelo.

# 4. Si el valor del "peso" (que est√° dentro de la clave ("dimensiones", "peso")) es menor o igual a "1.5kg" 
# (extraer la parte numerica de ese str y remplaza 'el texto 'kg' por '', y conviertelo a float),
# aplica un 20% de descuento sobre el "precio" (modifica el valor del precio).

# 5. Extrae solo los valores num√©ricos de las "dimensiones" y gu√°rdalos en una list (identifica el separador y str.split('separador')-> list).
# tendras que limpiar el ultimo elemento con str.replace('cm', ''), luego conviertelos a float.

# 6. Finalmente, imprime en consola el mensaje:
# print(f'Escr√≠bele a "{nombre_proveedor}" al correo "{email_proveedor}" para pedir descuento del producto "{nombre_producto}".')

print('=='*30, 'EJERCICIO #4', '=='*30)
import copy
producto = {
    "nombre": "Laptop XYZ",
    "precio": 1200.50,
    "en_stock": True,
    101: "Electr√≥nica",
    "caracter√≠sticas": ["16GB RAM", "512GB SSD", "Intel i7"],
    "proveedor": {
        "nombre": "Proveedor ABC",
        "contacto": "contacto@abc.com"
    },
    ("dimensiones", "peso"): ["30cm x 20cm x 2cm", "1.5kg"],
    (2023, 9, 15): "Fecha de lanzamiento"
}
************************************************Codigo Solucion....******************************************



# *******************************************************set
# colecci√≥n no ordenada de elementos √∫nicos, irrepetibles y mutables. 
# Puedes agregar o quitar elementos despu√©s de crear el set.
# *Caracter√≠sticas:
#No hay duplicados.
#Desordenados, NO puedes accederlos por √≠ndice.
# Solo pueden contener elementos inmutables (por ejemplo, n√∫meros, strings, tuplas).
# Usados para para eliminar duplicados y realizar operaciones de conjuntos matem√°ticos (uni√≥n, intersecci√≥n, diferencia).
# Creacion con llaves {}:
************************************************Codigo explicacion....******************************************











# ********************************************Unpacking de TDD Iterables
# 1. Para¬†asignaci√≥n simultanea y r√°pida de los elementos de un iterable (lista, tupla, str, etc.) a variables individuales.
# 2. Para¬†crear combinaci√≥n de colecciones o cambiar el TDD de la secuencia.
# 3. ‚è∞Para¬†pasar argumentos din√°micos a funciones¬†de forma clara y concisa.


# *1. Asignaci√≥n simult√°nea de elementos de ITERABLES a variables individuales
# Ejemplo 1: Unpacking con list, lo mismo con str, set, dict (pero en diccionarios solo las llaves)
************************************************Codigo explicacion....******************************************




ACA QUEDAMOS!!!!!!!!!!!!
# *‚ö†Ô∏èüí°üëÄ Cuando haces unpacking en variables, debes:
#  Tener tantas variables como elementos tenga el iterable en ese momento, o lanzar√° ValueError.
# O usa el operador¬†*¬†para capturar varios elementos o el resto.

# Ejemplo 3: Unpacking con operador *
************************************************Codigo explicacion....**************************

# *2. Combinaci√≥n de colecciones o cambiar el TDD de la secuencia.
************************************************Codigo explicacion....*************************


#  ******************************FUNCIONES CON def ******************************************
# Bloque de c√≥digo de sentencias que realiza una tarea espec√≠fica en el programa, 
# siendo reusable. Usamos funciones para modular y evitar la repetici√≥n. 
# La keyword "def" es usada para definir una funci√≥n.
# 
# ‚≠êArgumentos: datos que pueda necesitar una funci√≥n para realizar su tarea, y
# ser√°n pasados dentro de sus parentesis de ejecucion, separados por ","
# pasa tantos, como par√°metros se haya declarado en su definici√≥n, 
# a menos que sean variables globales.  
# 
# ‚≠êLa funci√≥n podr√≠a o no retornar un valor o resultado, con la instrucci√≥n return.
# return termina una funci√≥n y opcionalmente devuelve un valor.

# *SINTAXIS:
#  def nombre_funcion(par√°metros_opcionales):
#     # Bloque de c√≥digo indentado que define lo que hace la funci√≥n
#     instrucciones
#     return valor_retorno_opcional
# Ejemplos:
# ************************************************Codigo explicacion....*********************


#  ******************************√ÅMBITO DE VARIABLES GLOBALES EN FUNCIONES**************************
# ‚≠êPor default, en √°mbito local, solo podemos leer una variables globales, 
# ‚ùåNO modificarla.
# Dentro de un √°mbito local (funci√≥n), puedes modificar una variable global, 
# usar la keyword global antes de intentar modificarla. Como 1era declaracion en la func
# ‚ö†Ô∏èCuidado, la modificaci√≥n afectara el valor de la variable, local y globalmente.
# Esto NO es una buena practica‚ö†Ô∏è

# üìñüí°‚≠êLa imposibilidad de modificar variables globales en √°mbitos de d funciones, 
# NO ocurre en los bucles, porque estos NO crea un nuevo √°mbito. 
# Est√°rias trabajando directamente en el √°mbito global donde la variable fue definida
# ************************************************Codigo explicacion....***************************


#*ARGUMENTOS POSICIONALES Y POR PALABRA CLAVE EN FUNCIONES
# Cuando ""llamas""" a una funci√≥n, puedes pasar los """argumentos""" de dos maneras:

# *1Ô∏è‚É£Argumentos posicionales: Se pasan en el mismo orden en que los PAR√ÅMETRO est√°n definidos.
# *2Ô∏è‚É£Argumentos por palabra clave: Puedes especificar los argumentos usando los nombres de los PAR√ÅMETRO, 
# te permite cambiar el orden.
# *3Ô∏è‚É£Valores por defecto: Puedes asignar un valor por defecto a un PAR√ÅMETRO al definir la funci√≥n. 
# Esto hace que ese par√°metro sea opcional. Si el usuario no lo proporciona, se usar√° el valor por defecto. 
# ‚ö†Ô∏è‚ùåLos par√°metros con valores por defecto siempre deben ir despu√©s de los par√°metros sin valores por defecto, 
# de lo contrario generaras un Error ‚ùå
# ************************************************Codigo explicacion....********************************
#*‚õπüèΩ‚Äç‚ôÇÔ∏è‚õπüèΩ‚Äç‚ôÄÔ∏è‚õπüèΩ‚Äç‚ôÇÔ∏è‚õπüèΩ‚Äç‚ôÄÔ∏èüí°EJERCICIO #1:Funciones
# Crear un programa que verifique si una persona es mayor de edad. 
# Para ello, debes crear una funci√≥n que reciba 
# la edad como par√°metro y devuelva True si la persona 
# es mayor de edad o False si no lo es.

#*‚õπüèΩ‚Äç‚ôÇÔ∏è‚õπüèΩ‚Äç‚ôÄÔ∏è‚õπüèΩ‚Äç‚ôÇÔ∏è‚õπüèΩ‚Äç‚ôÄÔ∏èüí°EJERCICIO #2:Funciones
Crea una funci√≥n que calcule el precio final de un producto despu√©s de aplicar un descuento. 
La funci√≥n debe recibir de usuario con input(), el precio original, el porcentaje de descuento, 
y si aplica el descuento (si/no), y devolver el precio final, lo que depender√° de si aplica o no 
el descuento.

aplica_descuento(p, t, aplica):
    if aplica == 'si'
        result = p - (( p * t ) % 100 )
aplica_descuento(100, 20, 'no'):
